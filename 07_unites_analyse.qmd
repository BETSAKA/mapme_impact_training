---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Clarification sur les unités d'analyse

## Quelles unités d'analyse

On souhaite définir une stratégie empirique pour évaluer une politique publique avec des méthodes quantitatives, trois choix principaux doivent être définis : 

1. Quel types d'unités allons-nous comparer ? (Quelles lignes dans mon tableau ?)
2. Quelles variables prendre en compte ? (Quelles colonnes dans mon tableau ?)
3. Comment constituer une comparaison crédible ? (Quelle méthode d'analyse et quelles spécifications ?)

On se focalise souvent sur les questions 2. et 3, mais la question 1. est souvent considérée comme évidente. Cette question 1. suscite pourtant beaucoup de confusion quand on apprend l'économétrie. 

Nous allons illuster cette question avec le cas de la conservation. Typiquement, les évaluations de l'impact des politiques de conservation prennent habituellement comme référence (comme ligne du tableau) : 

- Des pays, pour voir comment la présence d'aires protégées à l'échelle nationale influence la distribution d'autres variables également à l'échelle nationale,  cf. []
- Des unités administratives, comme des communes, cf. []
- Des zones géographiques d'une échelle assez fine (par exemple, 1 km2), cf. par exemple Wolf et al. []
- Des pixels à l'échelle la plus fine où ils sont disponible, généralement en effectuant un tirage alétaoire, cf. par exemple Devenish et al. []

Une approche courante consiste à diviser le territoires en mailles, carrées ou en forme d'alvéoles d'abeilles (hexagones), et à calculer des indicateurs pour chacune de ces mailles.

## Constitution d'un maillage

On montre ci-dessous comment cette approche fonctionne. La première étape consiste à dessiner un carré autour des aires protégées malgaches, puis à subdiviser ce grand carré en un damier de formes hexagonales. Enfin, on ne garde que les hexagones qui se trouvent dans les frontières terrestres de Madagascar.

```{r Données satellitaires}
library(tidyverse)
library(tmap)
library(sf)
library(mapme.biodiversity)
library(geodata)

contour_mada <- gadm(country = "Madagascar", resolution = 1, level = 0,
                     path = "data") %>%
  st_as_sf() %>%
  st_transform("EPSG:29739") # On utilise la projecton officielle pour Mada
  
  # Création d'un maillage du territoire émergé --------------------------------
  
  # On crée un cadre autour des frontières nationales
cadre_autour_mada = st_as_sf(st_as_sfc(st_bbox(contour_mada))) %>%
  st_make_valid()

# Surface des hexagones en km2
taille_hex <- 5

# Cellules de 5km de rayon
surface_cellule <- taille_hex * (1e+6)
taille_cellule <- 2 * sqrt(surface_cellule / ((3 * sqrt(3) / 2))) * sqrt(3) / 2
grille_mada <- st_make_grid(x = cadre_autour_mada,
                            cellsize = taille_cellule,
                            square = FALSE) 
# On découpe la grille pour ne garder que les terres émergées
cellules_emergees <- contour_mada %>%
  st_intersects(grille_mada) %>%
  unlist()
grille_mada <- grille_mada[sort(cellules_emergees)] %>%
  st_sf()
```

Le maillage produit est trop fin pour être visible à l'échelle du pays, mais on peut l'observer en zoomant sur une zone spécifique.

```{r Carte grille mada}
## Carte de droite : zoom sur une zone spécifique-----------------------------
# On crée une boîte de 100km autour de Maroantsetra
zoom_boite <- st_point(c(49.74229,-15.43487)) %>% # Coordonnées de Maroantsetra
  st_sfc(crs = "EPSG:4326") %>% # On précise que c'est du GPS initalement
  st_transform(crs = "EPSG:29739") %>% # On passe en projeté
  st_buffer(dist = 50000) %>% # On crée un cercle de 50km de rayon
  st_make_grid(n = 1) 

# On filtre les alvéoles pour ne garder que celles qui sont dans le zoom
grille_zoom <- st_intersection(grille_mada, zoom_boite)

tmap_mode("view")
# On génère la carte de droite
tm_shape(grille_zoom) + 
  tm_borders() +
  tm_basemap("OpenStreetMap")
```

## Récupération des données pour le maillage

On va ensuite utiliser [le package mapme.biodiversity](https://mapme-initiative.github.io/mapme.biodiversity/index.html) pour calculer, pour chaque hexagones, une série d'indicateurs : temps de parcours jusqu'à la ville (définie comme toute localité de 5000 habitants) la plus proche en 2015, teneur du sol en argile et couvert forestier par année).

``` {r}
#| eval: false


if (file.exists("data/grille_mada_donnees_raster.rds")) {
  load("data/grille_mada_donnees_raster.rds")
} else {
  
  # Traitement des données satellitaires avec {mapme.bidiversity}---------------
  
  # Définir le répertoire de sortie
  mapme_options(outdir = "data/mapme")
  
  # Acquisition des données satellitaires requises (rasters)
  
  grille_mada <-  get_resources(x = grille_mada, 
                                get_nelson_et_al(ranges = "5k_110mio"),
                                get_gfw_treecover(),
                                get_gfw_lossyear(),
                                get_nasa_srtm(),
                                get_worldpop(),
                                get_mcd64a1())
  
  # Calcul des indicateurs

  grille_mada <- calc_indicators(x = grille_mada,
                                 calc_traveltime(),
                                 calc_population_count(),
                                 calc_slope(),
                                 calc_elevation(),
                                 calc_treecover_area(),
                                 calc_burned_area())
  
  # Sauvegarde du résultat
  save(grille_mada, file = "data/grille_mada_mapme.rds")
}

# Assemblage des deux cartes ---------------------------------------------------
tmap_arrange(carte_grille, carte_zoom, ncol = 2) 

```

On peut représenter sous forme de cartes et d'histogrammes les différentes valeurs des indicateurs générés à partir des données satellitaires.

```{r Synthèse données satellitaires, fig.fullwidth = TRUE}
if (file.exists("data/carte_mailles.rds")) {
  load("data/carte_mailles.rds")
} else {
  grille_mada_summary <- grille_mada %>%
    # On met à plat les données de distance
    unnest(cols = c(traveltime, soilproperties, tri, elevation),
           names_repair = "universal") %>%
    select(-distance, -layer, -depth, -stat,  -active_fire_counts, 
           -active_fire_properties) %>%
    rename(distance_minutes_5k_110mio = minutes_mean, mean_clay_5_15cm = mean) 
  
  grille_mada_summary <- grille_mada_summary %>%
    unnest(cols = treecover_area_and_emissions) %>%
    pivot_wider(names_from = "years", values_from = c("treecover", "emissions")) %>%
    mutate(var_treecover = (treecover_2020 - treecover_2000)/treecover_2000,
           sum_emissions = rowSums(across(starts_with("emission")), na.rm = T)) %>%
    rename(init_treecover_2000 = treecover_2000) %>% # pour le garder
    select(-starts_with("treecover"), -starts_with("emission")) %>%
    rename(treecover_2000 = init_treecover_2000) %>%
    relocate(geometry, .after = last_col())
  
  carte_acces <- tm_shape(grille_mada_summary) +
    tm_fill("distance_minutes_5k_110mio",
            title = "Distance ville (>5K hab)",
            palette = "Oranges",
            style = "fisher",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6,
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_sol <- tm_shape(grille_mada_summary) +
    tm_fill("mean_clay_5_15cm",
            title = "Sol argileux (5-15cm prof)",
            palette = "YlOrBr",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_TRI <- tm_shape(grille_mada_summary) +
    tm_fill("tri_mean",
            title = c("Terrain accidenté (TRI)"),
            palette = "Blues",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6,
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_alt <- tm_shape(grille_mada_summary) +
    tm_fill("elevation_mean",
            title = "Altitude",
            palette = "Purples",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6,
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_cover <- graph_alt <- tm_shape(grille_mada_summary) +
    tm_fill("treecover_2000",
            title = "Couvert arboré en 2000",
            palette = "Greens",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6,
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_loss <- graph_alt <- tm_shape(grille_mada_summary) +
    tm_fill("var_treecover",
            title = "Perte couvert (2000-2020)",
            palette = "Reds",
            n = 8,
            legend.hist = TRUE) +
    tm_layout(legend.outside = TRUE,
              # legend.title.size = 0.8,
              # legend.text.size = 0.6,
              legend.hist.width = 1,
              legend.hist.height = 1)
  
  carte_mailles <- tmap_arrange(carte_acces, carte_sol, 
                                carte_alt, carte_TRI, 
                                carte_cover, carte_loss,
                                ncol = 2, nrow = 3) %>%
    tmap_save("data/carte_mailles.png")
}

carte_mailles
```


Les cartes et histogrammes ci-dessus illustrent la distribution des variables spatiales calculées par hexagones. 

## Croisement des données d'aires protégées et satellitaires

On peut maintenant associer les données d'aires protégées aux hexagones afin de les croiser avec les indicateurs issus des données satellitaires déjà calculés pour ces hexagones.

```{r Jointure aires protégées et données satellitaires}
if (file.exists("data/grille_mada_AP.rds")) {
  load("data/grille_mada_AP.rds")
} else {
  # On charge les données d'aires protégées élaborées au chapitre précédent
  load("data/ch3_AP_Vahatra.rds")
  
  # On prépare ces données pour les joindre avec celles en mailles
  aires_prot_mada <- AP_Vahatra %>%
    st_make_valid() %>% # Corrige les erreurs topo dans certains polygones
    mutate(AP_ligne = row_number()) %>% # Intègre le numéro de ligne dans un champ
    mutate(an_creation = year(date_creation)) # passe les dates en années
  
  # Le code suivant va asocier les hexagones aux aires protégées en se référant
  # aux AP par leur rang dans la table des AP. On voudra plutôt leur identifiant, 
  # alors on crée une table d'équivalence rang/identifiant 
  aires_prot_mada_rang_id <- aires_prot_mada %>%
    st_drop_geometry() %>% # Enlève l'information spatiale
    select(AP_ligne, nom)
  
  
  # On sélectionne des infos additionnelles qu'on va inclure dans les données
  info_vahatra_a_inclure <- aires_prot_mada %>%
    st_drop_geometry() %>% # Enlève l'information spatiale
    select(AP_ligne, nom, an_creation, cat_iucn = cat__iucn, 
           gestionnaire = gest_2) # On ne garde que les variables d'intérêt
  
  # Pour chaque hexagone, on va maintenant identifier s'ils touchent ("intersect")
  # ou s'ils sont strictiement inclus dans ("within") une aire protégé
  grille_mada_AP <- grille_mada %>%
    mutate(AP_ligne = st_intersects(., aires_prot_mada), # liste des n° de lignes d'AP qui recoupent
           AP_ligne = map(AP_ligne, 1), # On extrait le 1° élément de la liste (toutes n'ont qu'1 élément)
           AP_ligne = as.integer(as.character(AP_ligne))) %>%  # formattage en numérique
    left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>% # récupère l'id de l'AP
    rename(AP_touche = nom) %>% # on renomme pour différentier
    mutate(AP_ligne = st_within(., aires_prot_mada),
           AP_ligne = map(AP_ligne, 1),
           AP_ligne = as.integer(as.character(AP_ligne))) %>%
    left_join(aires_prot_mada_rang_id, by = "AP_ligne") %>%
    rename(AP_inclus = nom) %>%
    select(-AP_ligne) 
  
  grille_mada_AP <- grille_mada_AP %>%
    st_sf() %>%
    mutate(position_ap = ifelse(is.na(AP_touche), "Extérieur",
                                ifelse(!is.na(AP_inclus), "Intérieur",
                                       "Frontière")),
           ref_AP = ifelse(position_ap == "Intérieur", AP_inclus, 
                           ifelse(position_ap == "Frontière", AP_touche, NA))) %>%
    left_join(info_vahatra_a_inclure, by = c("ref_AP" = "nom")) %>%
    relocate(geometry, .after = last_col()) 
  
  grille_mada_AP <- grille_mada_AP %>%
    # On met à plat les données de distance
    unnest(cols = c(traveltime, soilproperties, tri, elevation),
           names_repair = "universal") %>%
    select(-distance, -layer, -depth, -stat,  -active_fire_counts, 
           -active_fire_properties) %>%
    rename(distance_minutes_5k_110mio = minutes_mean, mean_clay_5_15cm = mean)
  save(grille_mada_AP, file = "data/grille_mada_AP.rds")
}

# Une vue après classification
tm_shape(grille_mada_AP) +
  tm_fill(col = "position_ap", title = "par rapport aux aires protégées") +
  tm_layout(main.title = "Localisation des hexagones",
            # NB : position en minuscules pour laisser un espace avec la marge
            main.title.position = c("center", "top"),
            main.title.size = 1,
            legend.position = c("left", "top"),
            legend.outside = FALSE)
```

