[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Evaluation d’impact de politiques et projets spatialisés",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#démarche",
    "href": "index.html#démarche",
    "title": "Evaluation d’impact de politiques et projets spatialisés",
    "section": "Démarche",
    "text": "Démarche\nCe contenu est un support de formation conçu pour initier à l’économétrie spatiale chercheurs, doctorants et étudiants s’orientant vers une thèse. Ce document a été élaboré avec les priorités suivantes :\n\nCompréhension des enjeux théoriques et méthodologiques soulevés par les évaluations d’impact ;\nIdentification des spécificités et opportunités liées à l’évaluation d’interventions spatialisées ;\nObtention de données spatiale permettant de démontrer et de quantifier l’impact ;\nCompréhension des différentes approches pour constituer un contrefactuel : randomisation, appariement, comparaison avant-après, différence de différences ;\nFamiliarisation avec l’outil de traitement statistique R;\nDéveloppement d’un regard critique sur la pertinence et la fiabilité des données mobilisées.\n\nD’autres aspects ont volontairement été placés au second plan, en particulier les subtilités associées aux modèles économétriques. Les méthodes économétriques mobilisées ici sont volontairement simples : pour être publiable dans une revue scientifique, un travail d’évaluation doit mobiliser des spécifications plus sophistiquées.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#contributions",
    "href": "index.html#contributions",
    "title": "Evaluation d’impact de politiques et projets spatialisés",
    "section": "Contributions",
    "text": "Contributions\nCet ouvrage a bénéficié de nombreuses contributions :\n\nPour la première édition : Marc Bouvier, Kenneth Houngbedji, Jeanne de Montalembert et Marin Ferry ;\nPour la seconde édition : Lenaïg Moign et Clément Sambandahy ;\nPour la troisième édition : Ingrid Dallmann et Melvin Wong.\n\nPhoto en couverture : “Déforestation à Madagascar” © IRD - Bernard Moizo",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01_introduction.html",
    "href": "01_introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "bases_R.html",
    "href": "bases_R.html",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "",
    "text": "2.1 L’environnement",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "bases_R.html#lenvironnement",
    "href": "bases_R.html#lenvironnement",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "",
    "text": "2.1.1 Différences R et Rstudio\nR est un langage de programmation open source spécialisé dans la statistique et l’analyse des données. Il a été créé pour fournir un environnement convivial pour la manipulation, l’analyse et la visualisation des données.Il existe d’autres langages de programmation comme Python, JavaScript, Java, C++, etc.\nR est utilisé pour effectuer des opérations statistiques, faire de la modélisation, créer des graphiques et effectuer des analyses de données complexes.\nR est extrêmement flexible et extensible grâce à des packages R, qui ajoutent des fonctionnalités supplémentaires.\nRStudio est un environnement de développement intégré (IDE) conçu spécifiquement pour travailler avec le langage R. C’est un logiciel qui fournit une interface utilisateur plus conviviale pour écrire, exécuter et gérer des scripts R. Il existe d’autres IDE, comme Visual Studio Code ou Jupyter Notebook.\nRStudio inclut un éditeur de texte avec coloration syntaxique, un gestionnaire de packages, des fenêtres pour l’affichage des graphiques et des données, et bien d’autres fonctionnalités pour améliorer la productivité des utilisateurs R.\nEn somme, R est le langage de programmation sous-jacent pour l’analyse des données, tandis que RStudio est un environnement de développement qui facilite l’utilisation de R.\n\n\n2.1.2 Sources d’apprentissage\nIl existe de plusieurs ressources en français pour apprendre à coder sur R. Nous vous recommandons en particulier :\n\nIntroduction à R et au Tidyverse (Barnier 2022)\nutilitR: documentation collaborative sur R de l’INSEE (Galiana and Meslin 2022)\n\nLes bonnes ressources anglophones gratuites sont très nombreuses et faciles à trouver sur Internet. Le grand classique est R for data science, de Grolemund et Wickham (2022). On se focalise ici avec deux autres qui sont le plus en lien avec nos sujets :\n\nGeocomputation with R, a book on geographic data analysis,visualization and modeling (Lovelace, Nowosad, and Muenchow 2022).\nMapme.biodiversity: Efficient Monitoring of Global Biodiversity Portfolios (Görgen and Bhandari 2022)\n\nN’hésitez pas à chercher directement sur le Web en cas de problème. Vous serez souvent conduits vers les forums stackoverflow ou RStudio, qui sont aussi des ressources très précieuses pour résoudre des problèmes très spécifiques.\nPour un apprentissage interactif, vous pouvez également utiliser ChatGPT. Cet outil basé sur l’intelligence artificielle s’avère particulièrement utile pour les débutants qui ont besoin de support personnalisé ou pour les utilisateurs avancés comme assistant de programmation pour structurer des chaînes de traitement ou aider avec les problèmes les plus courants. Attention toutefois car il arrive régulièrement à ChatGPT “d’halluciner” des réponses lorsqu’il s’agit de questions très spécifiques.\nPour vous retrouver parmi la multitude de packages existants, il existe une ressource précieuse en ligne : CRAN Task View (https://cran.r-project.org/web/views/). Ce registre fournit des recommandations sur les packages présents sur CRAN adaptés à un sujet spécifique.\nIl existe également de superbes cheat-sheet (“antisèches”) qui récapitulent les principales ressource :\n\nhttps://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf\nhttps://rstudio.github.io/cheatsheets/\n\n\n\n2.1.3 Interface Rstudio\n\nA : fenêtre script/source B : console C : environnement D : explorateur\nLa fenêtre de script permet d’éditer les fichiers scripts en vue d’éxécuter le code.\nLa console est la fênetre où s’éxécute le code et où on peut directement taper des commandes. Il n’est pas obligatoire de passer par la fenêtre de script.\nLe signe “&gt;” dans votre console est appelé “invite de commande” ou “prompt”. C’est le symbole que la console utilise pour indiquer qu’elle est prête à recevoir des commandes ou des instructions de l’utilisateur. Une fois que vous voyez cet invite, vous pouvez commencer à entrer des commandes en utilisant le langage R. Après avoir entré une commande, vous appuyez sur Entrée pour l’exécuter.\nL’environnement rassemble des fonctionnalités pour suivre le fonctionnement de R, en faisant notamment apparaître les différents objets générés par notre script.\nL’explorateur permet de connaître les fichiers de notre ordinateur, de visualiser les rendus graphiques et cartographiqus, les différentes librairies et l’aide pour l’utilisation de ces dernières.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "bases_R.html#les-règles-de-codage",
    "href": "bases_R.html#les-règles-de-codage",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "2.2 Les règles de codage",
    "text": "2.2 Les règles de codage\nOn se focalise ici sur quelques aspects qui peuvent être requis pour la manipulation du code et à la marge.\n\n2.2.1 La lisibilité du code\nLorsqu’on saisit une commande, que ce soit dans la console ou dans la fenêtre de script, les espaces autour des opérateurs n’ont pas d’importance.\nLes trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code.\n\n\nCode\n# Ce qui suit un dièze n'est pas exécuté. On appelle ça un commentaire.\n\n# Les trois commandes seront comprises par le code\n10+2 \n\n\n[1] 12\n\n\nCode\n10 + 2 \n\n\n[1] 12\n\n\nCode\n10       +       2\n\n\n[1] 12\n\n\nPour les opérations plus complexes, il faut veiller à utiliser les parenthèses, sinon les résultats ne seront pas corrects :\n\n\nCode\n10 + 2 * 5 / 14 - 2 * 2 \n\n\n[1] 6.714286\n\n\nCode\n#&gt;[1] 6.714286\n\n(10 + (2*5)) / (14 - (2 * 2))  \n\n\n[1] 2\n\n\n\n\n2.2.2 L’assignation (création d’objets)\nLe signe &lt;- correspond à l’assignation d’une valeur à une variable dont on choisit le nom.\n\n# On commence par faire une opération simple\n3 + 4\n\n[1] 7\n\n# Ce qui équivaut à :\na &lt;- 3\nb &lt;- 4\na + b\n\n[1] 7\n\n# Et on peut également stocker le résultat dans une nouvelle variable\nc &lt;- a + b\nc\n\n[1] 7\n\n\nDu fait de l’assignation “&lt;-”, les valeurs sont automatiquement associées à l’objet et ce dernier apparaît dans la fenêtre environnement.\nDe manière générale, vous allez retrouver dans cette fenêtre tous les objets que vous avez créés après éxécution du code : que ce soit de simples variables, des tableaux, des fonctions, des objets graphiques, etc.\nQuand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue.\n\n\nCode\nx &lt;- 2\nx &lt;- 5\nx\n\n\n[1] 5\n\n\nCode\n#&gt; [1] 5\n\n\n\n\n2.2.3 Les différents types d’objets\nLes objets peuvent contenir tout un tas de données. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (’ ou “) :\n\nLa chaîne de caractères\n\n\n\nCode\nchien &lt;- \"Chihuahua\"\nchien\n\n\n[1] \"Chihuahua\"\n\n\nCode\n#&gt; [1] \"Chihuahua\"\n\n\nIci la variable “chien” est un objet contenant une chaîne de caractères.\nUn point important est relatif aux types des variables : numérique, catégorielles, textes, dates, spatiales… En général, les opérations ne peuvent concerner que des variables du même type. Les fonctions sont souvent contraignantes quant aux types des variables qu’elles prennent comme arguments.\n\n\nCode\n# Exemple avec une variable numérique et une variable caractère\nx &lt;- 5\ny &lt;- \"hello\"\n\n# Tentative d'addition de deux variables de types différents\n#resultat &lt;- x + y\n\n\n\nLes vecteurs\n\nLes vecteurs permettent de stocker des informations de même nature dans un unique objet. Exemple :\n\n\nCode\n# Si on continuait à créer des objets ponctuels :\ntaille1 &lt;- 156\ntaille2 &lt;- 164\ntaille3 &lt;- 197\ntaille4 &lt;- 147\ntaille5 &lt;- 173\n(taille1 + taille2 + taille3 + taille4 + taille5) / 5\n\n\n[1] 167.4\n\n\nCode\n#&gt; [1] 167.4\n\n\nPrécédemment, nous avons stockés différentes valeurs chiffrées sous plusieurs objets qui apparaissent dans notre fenêtre d’environnement.\n\n\nCode\ntailles &lt;- c(156, 164, 197, 147, 173)\n#&gt; [1] 156 164 197 147 173\n\n\nUn vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.\nIci la variable “tailles”est un vecteur contenant des valeurs chiffrées.\nCe qui est pratique avec les vecteurs, c’est qu’on peut alors leur appliquer des opérations qui s’appliqueront à l’ensemble des valeurs du vecteur.\n\n\nCode\n# Si l'on souhaite mettre la taille en mètres : \n\ntailles / 100 \n\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCode\n#&gt; [1] 1.56 1.64 1.97 1.47 1.73\n\ntailles_m &lt;- tailles / 100\ntailles_m\n\n\n[1] 1.56 1.64 1.97 1.47 1.73\n\n\nCode\n#&gt; [1] 1.56 1.64 1.97 1.47 1.73\n\n\nCela s’applique à tous les tyoes d’opérations.\n\nSans créer de nouvel objet, ajouter 10 cm aux tailles en centimètres et multiplier au carré les tailles en mètres\n\n\n\nCode\ntailles + 10\n\n\n[1] 166 174 207 157 183\n\n\nCode\n#&gt; [1] 166 174 207 157 183\ntailles_m^2\n\n\n[1] 2.4336 2.6896 3.8809 2.1609 2.9929\n\n\nCode\n#&gt; [1] 2.4336 2.6896 3.8809 2.1609 2.9929\n\n\nOn peut également appliquer des opérations spécifiques à chaque valeur à l’aide d’un autre vecteur :\n\n\nCode\n# Création d'un nouveau vecteur avec l'âge\nage &lt;- c(52, 82, 19, 49, 29)\n\n\n\nEn créant une nouvelle variable “age_tailles_m”, calculer le ratio de l’age par rapport à la taille en mètres\n\nL’Indice de Masse Corporelle se calcule de la manière suivante:\n\\[ IMC = poids (kg) / (taille (m))²\\]\n\nEn créant une nouvelle variable “imc”, calculez le ratio pour les 5 valeurs\n\n\n\nCode\ntailles &lt;- c(156, 164, 197, 147, 173)\npoids &lt;- c(45, 59, 110, 44, 88)\n\n\n\nLes data.frame\n\nUn data.frame est un tableau qui peut contenir différents types de données (nombres, chaînes de caractères, etc.) organisées en colonnes.\n\n# On commence par créer les variables (les colonnes du tableau)\nnoms &lt;- c(\"John\", \"Jack\", \"Cindy\", \"Samantha\")\nsexe &lt;- c(\"homme\", \"homme\", \"femme\", \"femme\")\nages &lt;- c(42, 57, 24, NA)\npoids &lt;- c(87, 73, NA, NA)\ntailles &lt;- c(174, 198, 192, 164)\n\n# On les rassemble dans un tableau \nma_table &lt;- data.frame(noms, sexe, ages, poids, tailles)\n\nma_table\n\n      noms  sexe ages poids tailles\n1     John homme   42    87     174\n2     Jack homme   57    73     198\n3    Cindy femme   24    NA     192\n4 Samantha femme   NA    NA     164\n\n\n\n\n2.2.4 Les noms d’objets\nLes noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat.\nDe manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets.\nDe même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 (trop long) ou à t1 (pas assez)\n\n\n2.2.5 Les fonctions\nR est constitué de fonctions. De nombreuses fonctions prédéfinies sont contenues dans la base de R ou dans des packages qu’on ajoute (que l’on verra plus tard). La meilleure manière de comprendre ce qu’est une fonction est d’en créer une soi même.\n\n# On crée une fonction \"ajoute\" qui prend deux paramètres. \n# x est un premier et y est celui qu'on ajoute\najoute &lt;- function(x, y) {\n  x + y\n}\n\n# On peut maintenant utiliser cette fonction\najoute(3, 4)\n\n[1] 7\n\n# On peut effectuer les mêmes opérations. Les valeurs a et b sont encore \n# en mémoire, donc on peut faire :\najoute(a, b)\n\n[1] 7\n\nc &lt;- ajoute(a, b)\nc\n\n[1] 7\n\najoute(c, a)\n\n[1] 10\n\n\nLorsque vous téléchargez un package (ou librairie), ce dernier charge en réalité un éventail de fonctions que vous pouvez explorer via l’aide.\n\n\nCode\n# la fonction sum() est une fonction de base de R, mais d'autres opérations plus complexes sous enregistrées dans des packages spécifiques\nsum(a,b)\n\n\n[1] 7\n\n\n\nExercice : rendre lisible le code ci-dessous\n\n\n\nCode\nx &lt;- 5*(3+2)-1\nif(x%%2==0) {print('Pair')} else{print('Impair')}\n\n\n[1] \"Pair\"\n\n\nCode\nfor(i in 1:10) {if(i%%2 == 0) {print(paste('Nombre pair :', i))} else{print(paste('Nombre impair :', i))}}\n\n\n[1] \"Nombre impair : 1\"\n[1] \"Nombre pair : 2\"\n[1] \"Nombre impair : 3\"\n[1] \"Nombre pair : 4\"\n[1] \"Nombre impair : 5\"\n[1] \"Nombre pair : 6\"\n[1] \"Nombre impair : 7\"\n[1] \"Nombre pair : 8\"\n[1] \"Nombre impair : 9\"\n[1] \"Nombre pair : 10\"\n\n\n\n\n2.2.6 Les valeurs manquantes\nLes valeurs manquantes sont fréquentes dans les jeux de données. Elles notées NA dans R (certaines peuvent avoir pour valeur NaN). On utilise la fonction na.rm= TRUE pour les éluder dans les opérations simples.\n\n\nCode\n# On peut reprendre le jeu de données ma_table \n# On peut faire une moyenne sur les tailles car on a toutes les variables\nmean(ma_table$tailles)\n\n\n[1] 182\n\n\nCode\nsum(ma_table$tailles)\n\n\n[1] 728\n\n\nCode\n# Mais la moyenne ne fonctionne pas immédiatement sur les poids ou les âges\n# car il manque des variables\nmean(ma_table$ages)\n\n\n[1] NA\n\n\nCode\nsum(ma_table$poids)\n\n\n[1] NA\n\n\nCode\n# Pour que cela fonctionne, il faut spécifier quoi faire des valeurs manquantes\n# en indiquant na.rm = TRUE (NA pour \"non-available\" et RM pour \"remove\")\nmean(ma_table$ages, na.rm = TRUE)\n\n\n[1] 41\n\n\nCode\nsum(ma_table$poids, na.rm = TRUE)\n\n\n[1] 160",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "bases_R.html#librairies-r",
    "href": "bases_R.html#librairies-r",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "2.3 Librairies R",
    "text": "2.3 Librairies R\nLes librairies R sont communément appelées “packages”. Plusieurs packages R sont utilisées pour ce projet. Les packages dans R sont des extensions de logiciels qui ajoutent des fonctionnalités spécifiques au langage R de base.\nIls sont conçus pour faciliter l’analyse de données, la visualisation, la modélisation statistique, et bien plus encore. Les packages sont comme des boîtes à outils virtuelles qui permettent aux utilisateurs d’effectuer des tâches analytiques avancées sans avoir à réinventer la roue à chaque fois. Ils permettent de gagner du temps et de se concentrer sur la résolution de problèmes spécifiques à son domaine d’étude, au lieu de vous soucier de la programmation de fonctions de base.\nLors de la rédaction de publications scientifiques, il est important de citer correctement les packages R utilisés dans votre analyse. Assurez-vous d’inclure le nom complet du package ainsi que le nom de son auteur ou des auteurs. Zotero et RStudio permettent aisément d’inclure ces citations dans votre analyse.\nLes autres packages mobilisés dans pour ce cours sont listés dans le bloc de code ci-dessous :\n\n\nCode\nlibrary(\"tidyverse\") # Une série de packages pour faciliter la manipulation de données\nlibrary(\"readxl\") # Pour lire les fichiers excel (Carvalho et al. 2018)\nlibrary(\"gt\") # Pour des rendus graphiques harmonisés html et pdf/LaTeX\nlibrary(\"wdpar\") # Pour télécharger simplement la base d'aires protégées WDPA\n\n\n\n2.3.1 Le tidyverse\nLe “tidyverse” st un ensemble cohérent de packages R conçus pour la manipulation, la visualisation et l’analyse de données de manière cohérente et efficace. Il a été développé pour simplifier le flux de travail de l’analyse de données et pour rendre le code plus lisible et plus facile à comprendre.\n\n\n2.3.2 L’opérateur pipeline\nLe signe %&gt;% est un “tuyau”. On peut le lire à haute voix comme “ensuite”. Par exemple :\n\nlibrary(tidyverse)\n\nd &lt;- a %&gt;%\n  ajoute(b) %&gt;%\n  ajoute(c)\n\n\n\n2.3.3 La préparation des données avec dplyr\nLe “tidyverse” comprend plusieurs packages populaires, et notamment,dplyr. Ce dernier est très utile pour épurer les données lorsque vous travaillez sur des tableaux (et donc sur des tables attributaires).\nIl est utilisé pour la manipulation de données, notamment le filtrage, la sélection, le regroupement et la création de nouvelles variables.\n\n# Un exemple qui combine ces opérations\nma_table %&gt;%\n  filter(!is.na(ages)) \n\n   noms  sexe ages poids tailles\n1  John homme   42    87     174\n2  Jack homme   57    73     198\n3 Cindy femme   24    NA     192\n\n#consulter la sortie de l'objet\n\nma_table %&gt;%\n  filter(!is.na(ages)) %&gt;%\n  select(sexe, ages, tailles, poids) \n\n   sexe ages tailles poids\n1 homme   42     174    87\n2 homme   57     198    73\n3 femme   24     192    NA\n\nma_table %&gt;%\n  filter(!is.na(ages)) %&gt;%\n  select(sexe, ages, tailles, poids) %&gt;%\n  group_by(sexe) %&gt;%\n  summarise(nb_pers = n())\n\n# A tibble: 2 × 2\n  sexe  nb_pers\n  &lt;chr&gt;   &lt;int&gt;\n1 femme       1\n2 homme       2\n\nma_table %&gt;%\n  filter(!is.na(ages)) %&gt;%\n  select(sexe, ages, tailles, poids) %&gt;%\n  group_by(sexe) %&gt;%\n  summarise(nb_pers = n(),\n            somme_poids = sum(poids, na.rm = TRUE),\n            taille_max = max(tailles, na.rm = TRUE),\n            age_moy = mean(ages, na.rm = TRUE))\n\n# A tibble: 2 × 5\n  sexe  nb_pers somme_poids taille_max age_moy\n  &lt;chr&gt;   &lt;int&gt;       &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n1 femme       1           0        192    24  \n2 homme       2         160        198    49.5\n\n# &gt; A tibble : 2 x 5 \n#   sexe  nb_pers somme_poids taille_max age_moy\n#   &lt;chr&gt;   &lt;int&gt;       &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n# 1 femme       1           0        192    24  \n# 2 homme       2         160        198    49.5\n\nVoici certaines de fonctions fondamentales du dplyr : - select : choisir des colonnes - filter : choisir des lignes - mutate : modifier des valeurs - group_by : variables pour des tris - summarise : créer des filtres\n\nExercice en groupe : à partir du tableau ventes_magasin, utiliser les fonctions précédentes et le pipe operator pour réaliser les opérations suivantes :\n\n\nSélectionnez uniquement les colonnes produit, quantite, et prix_unitaire du data frame ventes_magasin.\nNe conservez que les ventes où la quantité vendue est supérieure à 5 unités.\nAjoutez une nouvelle colonne nommée montant qui représente le montant total de chaque vente (quantité multipliée par le prix unitaire) et ajoutez-la au data frame.\nCréez un nouveau tableau ventes_par_produit, regroupez les données par produit pour calculer la quantité totale vendue de chaque produit.\nComplétez ce tableau avec le montant total et le nombre de ventes.\n\n\n\nCode\n# Création du data frame ventes_magasin\n\nventes_magasin &lt;- data.frame(\n  produit = c(\"Produit A\", \"Produit B\", \"Produit A\", \"Produit C\", \"Produit B\", \n              \"Produit A\", \"Produit C\", \"Produit B\", \"Produit A\"),\n  quantite = c(8, 4, 12, 6, 7, 9, 3, 11, 5),\n  prix_unitaire = c(10, 15, 8, 12, 20, 10, 18, 14, 9),\n  date_vente = ymd( # Cette fonction interprète des dates year-month-day\n    c(\"2023-01-05\", \"2023-01-08\", \"2023-01-09\", \"2023-01-10\", \"2023-01-15\", \n      \"2023-01-20\", \"2023-01-25\", \"2023-01-30\", \"2023-02-02\"))\n  )\n\n\n\n\n2.3.4 Les jointures\nJointures : fusionner deux tableaux par une variable d’identification (“clé”)\n\n\nCode\n# Tableau clients\nclients &lt;- data.frame(ID = c(1, 2, 3, 4),\n                      nom_client = c(\"Alice\", \"Bob\", \"Charlie\", \"David\"))\n\n# Tableau commandes\ncommandes &lt;- data.frame(ID = c(2, 3, 1, 4),\n                        montant = c(100, 150, 50, 200))\n\n# Jointure par ID\nresultat &lt;- inner_join(clients, commandes, by = \"ID\")\n\n\nCette opération exige toutefois que la variable d’identification soit écrite de manière identique dans les deux jeux de données.\nSupposons que l’on travaille sur les aires protégées à Madagascar et que l’on dispose de deux jeux de données provenant de sources différentes. On a alors des informations complémentaires que l’on souhaite fusionner en un seul tableau via le nom de l’aire protégée.\nIl faudra veiller à ce que les noms aient la même écriture (pas de différences avec des majuscules, des abréviations ou des noms raccourcis)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "bases_R.html#import-de-données",
    "href": "bases_R.html#import-de-données",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "2.4 Import de données",
    "text": "2.4 Import de données\nEn très bref :\n\nPour les fichiers excel ou csv, dans le volet “files” du panneau en bas à droite de l’interface Rstudio, cliquer sur le fichier en question et utiliser l’assistant d’import.\nPour les autres fichiers, se référer à l’aide ou chercher sur internet. Le cheat sheet”base R” présente les principales importations.\n\nConcernant les données d’aires protégées importées :\n\nLes études sur les aires protégées s’appuient fréquemment sur la base WDPA (World Database on Protected Area), consultable en ligne sur https://protectedplanet.net.\nLa base rassemblée par l’association Vahatra dans le cadre de la monographie qu’elle a coordonnée sur l’ensemble des aires protégées terrestres malgaches semble beaucoup plus fiable (Goodman et al. 2018). Les données en question sont disponibles sur le portail https://protectedareas.mg avec une licence creative commons (CC-BY).\n\nOn va désormais importer les données avec l’information géographique :\n\n2.4.1 Import et exploration des données Vahatra\n\n\nCode\n# On travaille maintenant le fichier excel\nAP_Vahatra &lt;- read_xlsx(\"data/AP_Vahatra.xlsx\")\n\n# On fait apparaître le nom des colonnes \ncolnames(AP_Vahatra)\n\n\n [1] \"nom\"                \"cat_iucn\"           \"creation\"          \n [4] \"date_creation\"      \"date_modification\"  \"mention_changement\"\n [7] \"hectares\"           \"num_atlas_\"         \"full_name\"         \n[10] \"province\"           \"region\"             \"district\"          \n[13] \"gest_1\"             \"gest_2\"             \"type_ap\"           \n[16] \"an_creation\"        \"nom_wdpa\"           \"geometry\"          \n[19] \"rownum\"            \n\n\nCode\n# On fait apparaître le nom des différentes aires protégées et leur catégorie IUCN \nAP_Vahatra %&gt;%\n  select(nom, cat_iucn) %&gt;%\n  filter(row_number() &lt;= 10)\n\n\n# A tibble: 10 × 2\n   nom                                     cat_iucn\n   &lt;chr&gt;                                   &lt;chr&gt;   \n 1 Agnakatrika                             VI      \n 2 Agnalazaha                              VI      \n 3 Ambatofotsy                             V       \n 4 Ambatotsirongorongo                     V       \n 5 Ambatovaky                              IV      \n 6 Ambohidray                              &lt;NA&gt;    \n 7 Ambohijanahary                          IV      \n 8 Ambohitantely                           IV      \n 9 Ambohitr'Antsingy Montagne des Français V       \n10 Amoron'i Onilahy                        V       \n\n\nCode\n# On fait apparaître le nom des parcs nationaux \nliste_PN &lt;- AP_Vahatra %&gt;%\n  filter(cat_iucn == \"II\") %&gt;%\n  select(nom) \n\n# Création d'une colonne pour la superficie en km² \nAP_Vahatra &lt;- AP_Vahatra %&gt;%\n  mutate(superficie_km2 = hectares * 0.01)\n\n# Tri des données de manière décroissante en fonction de la superficie en km²\nAP_Vahatra &lt;- AP_Vahatra %&gt;%\n  arrange(desc(superficie_km2))\n\n# Obtenir les 3 plus grandes aires protégées \nAP_Vahatra %&gt;% \n  slice_head(n = 3) %&gt;%\n  select(nom)\n\n\n# A tibble: 3 × 1\n  nom                                  \n  &lt;chr&gt;                                \n1 Complexe Zones Humides Mangoky Ihotry\n2 Makira                               \n3 Corridor Ankeniheny Zahamena         \n\n\nCode\n# Obtenir la superficie totale de toutes les aires protégées \nAP_Vahatra %&gt;%\n  summarise(sum(AP_Vahatra$superficie_km2))\n\n\n# A tibble: 1 × 1\n  `sum(AP_Vahatra$superficie_km2)`\n                             &lt;dbl&gt;\n1                           63725.\n\n\nCode\n# Résumé statistique des superficies en km² \nsummary(AP_Vahatra$superficie_km2)\n\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n   2.249   46.061  249.625  650.253  758.975 4265.942 \n\n\nCode\n# Aires protégées de superficie supérieure ou égale au 3ème quartile\nAP_Vahatra %&gt;%\n  filter(superficie_km2 &gt;= 758.975) %&gt;%\n  nrow()\n\n\n[1] 25\n\n\n\nExercice : quelles aires protégées ont été créées après 2000 et dont la gestion est assurée par l’Etat ? # Production d’un joli tableau synthétique\n\nLa fonction gt() permet d’obtenir des tableaux bien formatés. Si vous vous intéressez aux catégories IUCN et à leur superficie totale sur l’ensemble des aires protégées :\n\n\nCode\n# Calcul des superficies totales pour chaque catégorie IUCN \nAP_Vahatra_iucn &lt;- AP_Vahatra %&gt;%\n  filter(!is.na(cat_iucn)) %&gt;%\n  group_by(cat_iucn) %&gt;%\n  summarise(superficie_totale = sum(superficie_km2))\n\n# Production du tableau\nAP_Vahatra_iucn %&gt;%\n  gt() %&gt;%\n  cols_label(cat_iucn = \"Catégorie IUCN\",\n             superficie_totale = \"Superficie totale (km²)\") %&gt;%\n  tab_header(\n    title = \"Aires protégées de Madagascar : superficies par catégorie IUCN\") %&gt;%\n  tab_source_note(\"Source : données de l'association Vahatra\") %&gt;%\n  fmt_number(decimals = 2)\n\n\n\n\n\n\n\n\nAires protégées de Madagascar : superficies par catégorie IUCN\n\n\nCatégorie IUCN\nSuperficie totale (km²)\n\n\n\n\nI\n22.40\n\n\nII\n25,380.56\n\n\nIII\n44.17\n\n\nIV\n4,138.88\n\n\nV\n22,752.70\n\n\nVI\n8,265.72\n\n\n\nSource : données de l'association Vahatra\n\n\n\n\n\n\n\n\nAvant de créer le graphique en nuages de points, nous devons préparer un tableau qui résume la superficie cumulée des aires protégées en fonction de leur année de création.\n\n\nCode\nAP_superficie_annees &lt;- AP_Vahatra %&gt;%\n  group_by(an_creation) %&gt;%\n  summarise(superficie_annuelle = sum(superficie_km2, na.rm = TRUE)) %&gt;%\n  arrange(an_creation) %&gt;%\n  mutate(superficie_cumulée = cumsum(superficie_annuelle))\n\n\n\nCréer un tableau pour représenter cette donnée de manière élégante\n\n\n\n2.4.2 Production d’un joli graphique\nOn cherche à décrire la dynamique de création d’aires protégées en termes de superficie. L’objectif est d’obtenir un graphique en nuages de points avec, pour chaque année de création, la superficie totale d’aires protégées.\n\nExercice de groupe : réfléchir à un tableau nommé “AP_superficie_annees” qui se base sur le jeu de données AP_Vahatra et qui pourrait alimenter le graphique en nuages de points. Utiliser la fonction cumsum()\n\nUne fois le tableau AP_superficie_annees créé, vous pouvez éxecuter le code suivant :\n\n\nCode\n# Graphique en nuages de points \nggplot(data = AP_superficie_annees, aes(x = an_creation, y = superficie_cumulée)) +\n  geom_point() +\n  geom_line() +\n  labs(x = \"Année\", y = \"Superficie cumulée (km²)\") +\n  ggtitle(\"Superficie cumulée en fonction de l'année de création\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n2.4.3 Import et exploration des données World Database on Protected Areas\nAvant de télécharger depuis le web les données du WDPA, nous pouvons directement travailler sur la table attributaire (fichier Excel)\n\n\nCode\nlibrary(wdpar)\n# On regarde si les données WDPA sont disponibles sur l'ordinateur qui exécute\nif (file.exists(\"data/WDPA_Oct2024_MDG-shapefile.zip\")) {\n  # Si oui, on charge\n  WDPA_Mada &lt;- wdpa_read(\"data/WDPA_Oct2024_MDG-shapefile.zip\")\n} else {\n  # Si non, on télécharge depuis protectedplanet\n  WDPA_Mada &lt;- wdpa_fetch(\"Madagascar\",\n                      download_dir = \"data\")\n}\n\n\n\nExercice : comment auriez-vous comparer vos jeux de données Vahatra et WDPA_Mada ?\n\n\n\n2.4.4 Comparaison des données attributaires Vahatra et WDPA Madagascar\nOn peut déjà comparer le nombre d’aires protégées.\n\n\nCode\n# Comparaison nombres d'aires protégées Vahatra et WDPA\nAP_Vahatra %&gt;%\n  distinct(nom) %&gt;%\n  nrow()\n\n\n[1] 98\n\n\nCode\nWDPA_Mada %&gt;%\n  distinct(NAME) %&gt;%\n  nrow()\n\n\n[1] 167\n\n\nOn peut comparer les différences de dates et de statut.\n\n\nCode\n# Tout d'abord, on ne garde que les aires de WDPA qui apparaissent dans Vahatra\nWDPA_commun &lt;- WDPA_Mada %&gt;%\n  filter(NAME %in% AP_Vahatra$nom_wdpa) %&gt;%\n  filter(!(NAME == \"Analalava\" & IUCN_CAT == \"Not Reported\")) %&gt;%\n  filter(!(NAME == \"Site Bioculturel d'Antrema\" & IUCN_CAT == \"Not Reported\")) %&gt;%\n  filter(DESIG != \"UNESCO-MAB Biosphere Reserve\") %&gt;%\n  arrange(NAME)  %&gt;%\n  mutate(rownum = row_number())\n\n# On garde seulement les métadonnées que l'on veut comparer\nWDPA_a_comparer &lt;- WDPA_commun %&gt;% # On repart des AP communes\n  select(nom_wdpa = NAME, type_wdpa = INT_CRIT, cat_iucn_wdpa = IUCN_CAT,\n         year_wdpa = STATUS_YR) # On ne garde que les colonnes à comparer\n\nverif_meta_wdpa &lt;-AP_Vahatra %&gt;%\n  st_drop_geometry() %&gt;% # Pas besoin d'un jeu spatial\n  select(nom:date_modification, nom_wdpa) %&gt;% # colonnes à garder dans Vahatra\n  # On renomme la catégorie IUCN de Vahatra et on code les NA comme dans WDPA\n  mutate(cat_iucn = ifelse(is.na(cat_iucn), \"Not Reported\", cat_iucn)) %&gt;%\n  left_join(WDPA_a_comparer, by = \"nom_wdpa\") %&gt;% # On rassemble Vahatra et WDPA\n  # On compare les dates et statuts\n  mutate(`Différence de date` = year(date_creation) != year_wdpa,\n         `Différence de statut` = cat_iucn != cat_iucn_wdpa)\n\nverif_meta_wdpa %&gt;%\n  summarise(`Nombre d'aires protégées comparées` = n(),\n            `Différence de date` = sum(`Différence de date`),\n            `Différence de statut` = sum(`Différence de statut`)) %&gt;%\n  gt() %&gt;%\n  tab_header(title = paste(\"Différences entre les données de WDPA et celles de\",\n                     \"l'assciation Vahatra sur les aires protégées terrestres\",\n                     \"à Madagascar\"))\n\n\n\n\n\n\n\n\nDifférences entre les données de WDPA et celles de l'assciation Vahatra sur les aires protégées terrestres à Madagascar\n\n\nNombre d'aires protégées comparées\nDifférence de date\nDifférence de statut\n\n\n\n\n98\n68\n40",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "bases_R.html#import-des-données-géospatiales",
    "href": "bases_R.html#import-des-données-géospatiales",
    "title": "2  Fondamentaux pour l’utilisation de R",
    "section": "2.5 Import des données géospatiales",
    "text": "2.5 Import des données géospatiales\nOn va cette fois-ci importer les données avec l’information géographique :\n\nDonnées Vahatra\n\n\n\nCode\n# On importe dans R en pointant vers le fichier .geojson\nAP_Vahatra &lt;- st_read(\"data/AP_Vahatra.geojson\") \n\n\nReading layer `AP_Vahatra' from data source \n  `/home/onyxia/work/mapme_impact_training/data/AP_Vahatra.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 98 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 43.25742 ymin: -25.60502 xmax: 50.47724 ymax: -11.98301\nGeodetic CRS:  WGS 84\n\n\n\nLes limites communales :\n\n\n\nCode\nlibrary(geodata)\n\n# On enregistre les limites communales \ncontour_mada &lt;- gadm(country = \"Madagascar\", resolution = 1, level = 3,\n                     path = \"data/GADM\") %&gt;%\n  st_as_sf()\n\n# On enregistre contour_mada pour s'en servir par la suite\nsave(contour_mada, file = \"data/contour_mada.rds\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Fondamentaux pour l'utilisation de R</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Barnier, Julien. 2022. “Introduction à r Et Au Tidyverse.”\nhttps://juba.github.io/tidyverse/index.html.\n\n\nGaliana, Lino, and Olivier Meslin, eds. 2022. “utilitR:\nDocumentation Collaborative Sur r.” https://www.book.utilitr.org/.\n\n\nGörgen, Darius A., and Om Prakash Bhandari. 2022.\nMapme.biodiversity: Efficient Monitoring of Global Biodiversity\nPortfolios. https://CRAN.R-project.org/package=mapme.biodiversity.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2022. R for Data Science:\nImport, Tidy, Transform, Visualize, and Model Data. 1st edition.\nSebastopol, CA: O’Reilly Media. https://r4ds.had.co.nz/.\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2022.\nGeocomputation with R. Boca Raton London New York: Routledge.\nhttps://geocompr.robinlovelace.net/.",
    "crumbs": [
      "References"
    ]
  }
]